"""Infrastructure layer test fixtures - Real database and service integration.

These fixtures provide real database sessions and repository instances
for testing infrastructure components. Organized by infrastructure service categories:

- Identity/Metadata Services: Track entities WITH database IDs
- Repository Services: DBTrack models with relationships  
- Connector Services: External service models (LastFMTrackInfo, etc.)
- Database Integration: Real database sessions and repositories
"""

import pytest
from datetime import UTC, datetime

from src.domain.entities import Track, Artist, TrackList
from src.infrastructure.persistence.database.db_models import DBTrack, DBPlaylist


@pytest.fixture
def real_track_repository(db_session):
    """Real track repository with test database session."""
    from src.infrastructure.persistence.repositories.track import TrackRepositories
    return TrackRepositories(db_session).core


@pytest.fixture  
def real_playlist_repository(db_session):
    """Real playlist repository with test database session."""
    from src.infrastructure.persistence.repositories.playlist import PlaylistRepositories
    return PlaylistRepositories(db_session).core


@pytest.fixture
def real_track_repositories(db_session):
    """Real track repositories suite with test database session."""
    from src.infrastructure.persistence.repositories.track import TrackRepositories
    return TrackRepositories(db_session)


@pytest.fixture
def real_playlist_repositories(db_session):
    """Real playlist repositories suite with test database session."""
    from src.infrastructure.persistence.repositories.playlist import PlaylistRepositories
    return PlaylistRepositories(db_session)


@pytest.fixture
def db_track():
    """Database track for repository integration tests.
    Note: ID will be auto-generated by database to avoid conflicts.
    """
    import uuid
    unique_id = str(uuid.uuid4())[:8]
    
    db_track = DBTrack(
        title=f"Test Track {unique_id}",
        artists={"names": [f"Test Artist {unique_id}"]},
        duration_ms=200000,
        release_date=None,
        isrc=f"TEST{unique_id.upper()[:8]}",
        spotify_id=f"spotify_test_{unique_id}",
        mbid=f"mbid-test-{unique_id}"
    )
    # Set required relationships
    db_track.mappings = []
    db_track.likes = []
    db_track.plays = []
    return db_track


@pytest.fixture
def db_tracks():
    """Multiple database tracks for repository integration tests.
    Note: IDs will be auto-generated by database to avoid conflicts.
    """
    import uuid
    
    db_tracks = []
    for i in range(1, 4):
        unique_id = str(uuid.uuid4())[:8]
        
        db_track = DBTrack(
            title=f"Track {i} {unique_id}",
            artists={"names": [f"Test Artist {i} {unique_id}"]},
            duration_ms=200000,
            release_date=None,
            isrc=f"TEST{i}{unique_id.upper()[:4]}",
            spotify_id=f"spotify_test_{i}_{unique_id}",
            mbid=f"mbid-test-{i}-{unique_id}"
        )
        # Set required relationships
        db_track.mappings = []
        db_track.likes = []
        db_track.plays = []
        db_tracks.append(db_track)
    return db_tracks


@pytest.fixture
def db_playlist():
    """Database playlist for repository integration tests.
    Note: ID will be auto-generated by database to avoid conflicts.
    """
    db_playlist = DBPlaylist(
        name="Test Playlist",
        description="Test playlist description",
        track_count=0
    )
    # Set required relationships
    db_playlist.playlist_tracks = []
    return db_playlist


# =============================================================================
# IDENTITY/METADATA SERVICE FIXTURES - Track entities WITH database IDs
# =============================================================================

@pytest.fixture
def persisted_track():
    """Track entity with database ID for identity/metadata service testing.
    
    Used by: TrackIdentityResolver, ConnectorMetadataManager
    Architecture: These services work with persisted domain entities.
    """
    return Track(
        id=1,
        title="Home",
        artists=[Artist(name="Mac DeMarco")],
        album="2",
        duration_ms=210000,
        isrc="USWB11300001",
        connector_track_ids={
            "spotify": "4jbmgIyjGoXjY01XxatOx6",
            "lastfm": "https://www.last.fm/music/Mac+DeMarco/_/Home"
        }
    )


@pytest.fixture
def persisted_tracks():
    """Multiple Track entities with database IDs for batch operations."""
    return [
        Track(
            id=1,
            title="Home", 
            artists=[Artist(name="Mac DeMarco")],
            album="2",
            duration_ms=210000,
            connector_track_ids={"spotify": "4jbmgIyjGoXjY01XxatOx6"}
        ),
        Track(
            id=2,
            title="Falling",
            artists=[Artist(name="Chris Lake")], 
            album="Falling EP",
            duration_ms=180000,
            connector_track_ids={"spotify": "5Z7ygHQo02SUrFmcgpwsKW"}
        ),
        Track(
            id=3,
            title="Unknown Track",
            artists=[Artist(name="Unknown Artist")],
            duration_ms=200000
        )
    ]


@pytest.fixture 
def persisted_tracklist(persisted_tracks):
    """TrackList with persisted tracks for workflow testing."""
    return TrackList(tracks=persisted_tracks)


# =============================================================================
# REPOSITORY SERVICE FIXTURES - DBTrack models with relationships
# =============================================================================

@pytest.fixture
def db_track_with_relationships():
    """DBTrack model with loaded relationships for repository testing.
    
    Used by: TrackRepository, repository integration tests
    Architecture: Repository layer works with database models.
    Note: ID will be auto-generated by database to avoid conflicts.
    """
    import uuid
    
    # Generate unique identifiers to avoid conflicts between tests
    unique_id = str(uuid.uuid4())[:8]
    
    db_track = DBTrack(
        title=f"Home {unique_id}",
        artists={"names": [f"Mac DeMarco {unique_id}"]},
        album=f"Album {unique_id}", 
        duration_ms=210000,
        release_date=datetime(2012, 5, 3, tzinfo=UTC),
        isrc=f"ISRC{unique_id.upper()[:8]}",
        spotify_id=f"spotify_{unique_id}",
        mbid=f"mbid-{unique_id}"
    )
    # Initialize relationships to prevent lazy loading issues
    db_track.mappings = []
    db_track.metrics = []
    db_track.likes = []
    db_track.plays = []
    db_track.playlist_tracks = []
    return db_track


@pytest.fixture
async def persisted_db_track(db_session):
    """DBTrack model persisted to database with auto-generated ID.
    
    Used by: Tests that need DBTrack with actual database ID.
    Architecture: Repository layer works with database models.
    """
    import uuid
    
    # Generate unique identifiers to avoid conflicts between tests
    unique_id = str(uuid.uuid4())[:8]
    
    db_track = DBTrack(
        title=f"Persisted Track {unique_id}",
        artists={"names": [f"Persisted Artist {unique_id}"]},
        album=f"Persisted Album {unique_id}", 
        duration_ms=180000,
        isrc=f"PERSIST{unique_id.upper()[:8]}",
        spotify_id=f"spotify_{unique_id}",
        mbid=f"mbid-{unique_id}"
    )
    
    # Persist to database to get ID
    db_session.add(db_track)
    await db_session.commit()
    
    # Refresh with all relationships loaded to prevent lazy loading
    await db_session.refresh(
        db_track,
        ["mappings", "metrics", "likes", "plays", "playlist_tracks"]
    )
    
    # Explicitly initialize relationships for safe access
    db_track.mappings = db_track.mappings or []
    db_track.metrics = db_track.metrics or []
    db_track.likes = db_track.likes or []
    db_track.plays = db_track.plays or []
    db_track.playlist_tracks = db_track.playlist_tracks or []
    
    return db_track


@pytest.fixture
def db_tracks_with_relationships():
    """Multiple DBTrack models for batch repository testing.
    Note: IDs will be auto-generated by database to avoid conflicts.
    """
    import uuid
    
    db_tracks = []
    for i in range(1, 4):
        unique_id = str(uuid.uuid4())[:8]
        
        db_track = DBTrack(
            title=f"Track {i} {unique_id}",
            artists={"names": [f"Artist {i} {unique_id}"]},
            duration_ms=200000 + (i * 10000),
            spotify_id=f"spotify_id_{i}_{unique_id}",
            isrc=f"ISRC{i}{unique_id.upper()[:4]}",
            mbid=f"mbid-{i}-{unique_id}"
        )
        # Initialize relationships
        db_track.mappings = []
        db_track.metrics = []
        db_track.likes = []
        db_track.plays = []
        db_track.playlist_tracks = []
        db_tracks.append(db_track)
    return db_tracks


# =============================================================================
# CONNECTOR SERVICE FIXTURES - External service models
# =============================================================================

@pytest.fixture
def lastfm_track_info():
    """LastFMTrackInfo for connector conversion testing.
    
    Used by: LastFMConnector, external service integration tests  
    Architecture: Connector layer converts between external and domain models.
    """
    from src.infrastructure.connectors.lastfm import LastFMTrackInfo
    return LastFMTrackInfo(
        lastfm_title="Home",
        lastfm_artist_name="Mac DeMarco",
        lastfm_user_playcount=42,
        lastfm_global_playcount=1337420,
        lastfm_listeners=50000,
        lastfm_url="https://www.last.fm/music/Mac+DeMarco/_/Home",
        lastfm_album_name="2",
        lastfm_mbid="a1b2c3d4-e5f6-7890-abcd-ef1234567890"
    )


@pytest.fixture
def lastfm_track_infos():
    """Multiple LastFMTrackInfo instances for batch testing."""
    from src.infrastructure.connectors.lastfm import LastFMTrackInfo
    return [
        LastFMTrackInfo(
            lastfm_title="Home",
            lastfm_artist_name="Mac DeMarco", 
            lastfm_user_playcount=42,
            lastfm_global_playcount=1337420,
            lastfm_listeners=50000,
            lastfm_url="https://www.last.fm/music/Mac+DeMarco/_/Home"
        ),
        LastFMTrackInfo(
            lastfm_title="Falling",
            lastfm_artist_name="Chris Lake",
            lastfm_user_playcount=15,
            lastfm_global_playcount=890123,
            lastfm_listeners=25000,
            lastfm_url="https://www.last.fm/music/Chris+Lake/_/Falling"
        )
    ]


# =============================================================================
# DATABASE INTEGRATION FIXTURES - Real database sessions and repositories
# =============================================================================

@pytest.fixture
def mock_external_connector():
    """Mock external connector for infrastructure tests."""
    from unittest.mock import AsyncMock
    mock = AsyncMock()
    mock.get_tracks_by_ids.return_value = []
    mock.get_track_metadata.return_value = {}
    mock.search_tracks.return_value = []
    return mock